<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0f0f1a">
    <title>Terminal</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        html, body {
            height: 100%;
            width: 100%;
            background: #0f0f1a;
            overflow: hidden;
        }
        #terminal {
            width: 100%;
            height: 100%;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
        }
        .xterm {
            height: 100%;
            padding: 4px;
        }
        .xterm-viewport::-webkit-scrollbar {
            width: 6px;
        }
        .xterm-viewport::-webkit-scrollbar-track {
            background: #0f0f1a;
        }
        .xterm-viewport::-webkit-scrollbar-thumb {
            background: #3f3f5a;
            border-radius: 3px;
        }
        .error {
            color: #ef4444;
            padding: 20px;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="terminal"></div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script>
        const params = new URLSearchParams(window.location.search);
        const port = params.get('port') || 7681;
        const name = params.get('name') || 'terminal';

        document.title = name + ' - Terminal';

        const term = new Terminal({
            cursorBlink: true,
            fontSize: 14,
            fontFamily: 'Menlo, Monaco, "Courier New", monospace',
            theme: {
                background: '#0f0f1a',
                foreground: '#e4e4e7',
                cursor: '#6366f1',
                cursorAccent: '#0f0f1a',
                selection: 'rgba(99, 102, 241, 0.3)',
                black: '#1a1a2e',
                red: '#ef4444',
                green: '#22c55e',
                yellow: '#eab308',
                blue: '#3b82f6',
                magenta: '#a855f7',
                cyan: '#06b6d4',
                white: '#e4e4e7',
                brightBlack: '#3f3f5a',
                brightRed: '#f87171',
                brightGreen: '#4ade80',
                brightYellow: '#facc15',
                brightBlue: '#60a5fa',
                brightMagenta: '#c084fc',
                brightCyan: '#22d3ee',
                brightWhite: '#fafafa',
            },
        });

        const fitAddon = new FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(document.getElementById('terminal'));
        fitAddon.fit();

        // Connect to ttyd
        const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsUrl = `${protocol}//${location.hostname}:${port}/ws`;

        let socket;
        let reconnectAttempts = 0;

        function connect() {
            socket = new WebSocket(wsUrl);
            socket.binaryType = 'arraybuffer';

            socket.onopen = () => {
                console.log('Connected');
                reconnectAttempts = 0;
                // Send initial resize
                sendResize(term.cols, term.rows);
            };

            socket.onmessage = (event) => {
                if (event.data instanceof ArrayBuffer) {
                    const data = new Uint8Array(event.data);
                    if (data[0] === 0) {
                        term.write(data.slice(1));
                    } else if (data[0] === 1) {
                        // title update - ignore or use
                    }
                } else {
                    term.write(event.data);
                }
            };

            socket.onerror = (e) => {
                console.error('WebSocket error:', e);
            };

            socket.onclose = () => {
                console.log('Disconnected');
                if (reconnectAttempts < 5) {
                    reconnectAttempts++;
                    term.write('\r\n\x1b[33mReconnecting...\x1b[0m\r\n');
                    setTimeout(connect, 1000 * reconnectAttempts);
                } else {
                    term.write('\r\n\x1b[31mConnection lost. Refresh to retry.\x1b[0m\r\n');
                }
            };
        }

        function sendInput(data) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const payload = new Uint8Array(data.length + 1);
                payload[0] = 0;
                for (let i = 0; i < data.length; i++) {
                    payload[i + 1] = data.charCodeAt(i);
                }
                socket.send(payload);
            }
        }

        function sendResize(cols, rows) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                const msg = JSON.stringify({ columns: cols, rows: rows });
                const payload = new Uint8Array(msg.length + 1);
                payload[0] = 1;
                for (let i = 0; i < msg.length; i++) {
                    payload[i + 1] = msg.charCodeAt(i);
                }
                socket.send(payload);
            }
        }

        // Terminal input
        term.onData(sendInput);

        // Terminal resize
        term.onResize(({ cols, rows }) => sendResize(cols, rows));

        // Window resize
        window.addEventListener('resize', () => fitAddon.fit());

        // Start connection
        connect();

        // Focus terminal
        term.focus();
    </script>
</body>
</html>
